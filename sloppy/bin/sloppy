#!/bin/sh
# ShareX in a few lines of shell script!
# requires slop(1), ffmpeg(1)

FILE="/tmp/region_cap.mp4"
PIDFILE="$XDG_RUNTIME_DIR/sloppy.pid"

# value between 1 and 31, higher is better
QUANT="26"

# telegram limits 10 megabytes
FS_LIMIT="10M"

# telegram limits to 480p
WIDTH_MAX="854"

print_help() {
  cat <<EOH
sloppy <options>
  --no-mouse: Do not capture the mouse, nor follow its movements
EOH
  exit 1
}

clean_up() {
  local pidfile
  pidfile=$1

  if [ -e "$pidfile" ]; then
    pid=$(cat "$pidfile")

    # remove pidfile first in case ffmpeg is dead already
    rm -v "$pidfile"

    # we've already read the pid into mem anyway
    # but check to make sure there's something to pass to kill
    if [ -n "$pid" ]; then
      # shell builtin kill doesn't support signal names
      /bin/kill -SIGINT "$pid"
    fi
    # shell truthiness is the inverse of everything else :|
    return 0
  else
    return 1
  fi
}

region_cap() {
  # $x,$y are coords for capture | $w,$h dimensions of capture
  # $nw is the modified new width, usually copied from width
  local x y w h nw input cap_mouse pidfile follow_mouse
  read -r x y w h cap_mouse pidfile <<< "$1 $2 $3 $4 $5 $6"

  # scales the maximum width to WIDTH_MAX and then rounds the height down
  if [ "$w" -gt "$WIDTH_MAX" ]; then
    nw="854"
  else
    nw="$w"
  fi

  # only follow the mouse pointer if we're capturing it
  # this seems like a sane default for me, but I'm not sure about anyone else
  if [ "$cap_mouse" -eq "1" ]; then
    follow_mouse="-follow_mouse 100"
  else
    follow_mouse=""
  fi

  input=":0.0+$x,$y"
  # -vf scale="854:-2" \

  # we run ffmpeg in a child proc so we can write the pidfile on the main proc
  ffmpeg \
    -vsync passthrough -frame_drop_threshold 4 \
    -f x11grab \
    $follow_mouse \
    -draw_mouse "$cap_mouse" \
    -video_size "$w"x"$h" \
    -framerate 60 \
    -i "$input" \
    -vcodec libx264 \
    -vf scale="$nw:-2" \
    -preset ultrafast -crf:v "$QUANT" \
    -fs 10M \
    -y \
    "$FILE" &

  # write the pidfile
  pid="$!"
  printf -- "$pid" > "$pidfile"

  # wait for our children to exit
  wait "$pid"

  # finally, clean up
  # truncate the pidfile so we don't try to kill an exited process
  printf -- "" > "$pidfile"
  clean_up "$pidfile"
}

upload() {
  # curl -sS -F "files[]=@${FILE}" https://pomf.space/upload.php | jq '.files[0].url' | xsel --clipboard
  echo
}


main() {
  local x y w h g id mode cap_mouse pidfile pid

  mode="$1"

  if [ "$mode" = "--no-mouse" ]; then
    cap_mouse="0"
  else
    cap_mouse="1"
  fi

  # allow running a second instance of sloppy to stop capture
  # EG: hitting the hotkey for sloppy will gracefully terminate
  # if we've cleaned up, we're exiting gracefully
  clean_up "$PIDFILE" && exit 0

  output="$(slop -f "%x %y %w %h %g %i")"
  if [ "$?" -ne 0 ]; then
    exit
  fi

  read -r x y w h g id <<< "$output"
  region_cap "$x $y $w $h $cap_mouse $PIDFILE"
}

main $@
